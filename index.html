<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Impervious Percent Calculator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/4.5.0/fabric.min.js"></script>
    <style>
        #canvas-container { position: relative; margin-bottom: 20px; }
        #myCanvas { border: 1px solid black; }
        #legend div { width: 160px; height: 28px; margin: 4px; padding: 6px; color: white; font-weight: bold; text-align: center; }
        #summary { margin: 15px 0; font-size: 1.1em; font-weight: bold; background: #f8f9fa; padding: 12px; border-radius: 6px; }
        button { margin: 6px 4px; padding: 8px 14px; }
    </style>
</head>
<body>
    <h1>Impervious Percent Calculator</h1>
    <input type="file" id="pdf-upload" accept=".pdf">
    <button id="set-scale">Set Scale</button>
    <button id="add-polygon">Add Polygon</button>
    <select id="polygon-type">
        <option value="site">Site Boundary</option>
        <option value="building">Building</option>
        <option value="driveway">Driveway</option>
        <option value="patio">Patio</option>
        <option value="other-impervious">Other Impervious</option>
        <option value="pervious">Pervious</option>
    </select>
    <button id="delete-selected">Delete Selected</button>
    <button id="export-png">Export Canvas Only (PNG)</button>
    <button id="export-full">Export with Legend & Calc (PNG)</button>

    <div id="summary">Scale not set.</div>
    <div id="legend"></div>

    <div id="canvas-container">
        <canvas id="myCanvas" width="900" height="700"></canvas>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js';

        let canvas = new fabric.Canvas('myCanvas', { preserveObjectStacking: true });
        let scale = 0; // real feet per pixel
        let polygons = [];
        let selectedPolygon = null;
        let handles = [];
        let isSettingScale = false;
        let scalePoints = [];
        let isDrawing = false;
        let currentPoints = [];
        let currentType = '';
        let clickTimer = null;

        const polygonColors = {
    'site':             'rgba(0,   0,   255, 0.55)',   // medium blue
    'building':         'rgba(220, 20,  60,  0.70)',   // strong red
    'driveway':         'rgba(255, 140, 0,   0.70)',   // strong orange
    'patio':            'rgba(148, 0,   211, 0.65)',   // strong purple
    'other-impervious': 'rgba(105, 105, 105, 0.75)',   // strong gray
    'pervious':         'rgba(34,  139, 34,  0.55)'    // medium green
};

        // Populate legend
        const legendDiv = document.getElementById('legend');
        Object.entries(polygonColors).forEach(([type, color]) => {
            let div = document.createElement('div');
            div.style.backgroundColor = color;
            div.innerText = type.replace('-', ' ').toUpperCase();
            legendDiv.appendChild(div);
        });

        // PDF upload and render
        document.getElementById('pdf-upload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = function(event) {
                const loadingTask = pdfjsLib.getDocument({data: event.target.result});
                loadingTask.promise.then(pdf => {
                    pdf.getPage(1).then(page => {
                        const viewport = page.getViewport({scale: 1.6});
                        const pdfCanvas = document.createElement('canvas');
                        pdfCanvas.width = viewport.width;
                        pdfCanvas.height = viewport.height;
                        const context = pdfCanvas.getContext('2d');
                        page.render({canvasContext: context, viewport}).promise.then(() => {
                            canvas.setWidth(viewport.width);
                            canvas.setHeight(viewport.height);
                            canvas.setBackgroundImage(pdfCanvas.toDataURL(), canvas.renderAll.bind(canvas));
                        });
                    });
                });
            };
            reader.readAsArrayBuffer(file);
        });

        // Set scale
        document.getElementById('set-scale').addEventListener('click', () => {
            isSettingScale = true;
            scalePoints = [];
            alert('Click two points on a known dimension (e.g. property line).');
        });

        // Add polygon
        document.getElementById('add-polygon').addEventListener('click', () => {
            currentType = document.getElementById('polygon-type').value;
            isDrawing = true;
            currentPoints = [];
            alert('Click points to draw polygon → double-click to finish.');
        });

        // Delete selected
        document.getElementById('delete-selected').addEventListener('click', () => {
            if (selectedPolygon) {
                canvas.remove(selectedPolygon);
                polygons = polygons.filter(p => p !== selectedPolygon);
                removeHandles();
                selectedPolygon = null;
                updateSummary();
            }
        });

        // Export canvas only
        document.getElementById('export-png').addEventListener('click', () => {
            removeHandles();
            const dataURL = canvas.toDataURL({ format: 'png', multiplier: 2 });
            download(dataURL, 'impervious_canvas.png');
            // Re-add handles if something was selected
            if (selectedPolygon) addHandles(selectedPolygon);
        });

        // Export with legend + calculation
        document.getElementById('export-full').addEventListener('click', () => {
            removeHandles();

            const mainW = canvas.getWidth();
            const mainH = canvas.getHeight();
            const padding = 40;
            const legendW = 220;
            const textAreaH = 140;

            // Create off-screen canvas
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = Math.max(mainW, mainW + legendW + padding * 2);
            exportCanvas.height = mainH + textAreaH + padding * 2;
            const ctx = exportCanvas.getContext('2d');

            // White background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

            // Draw main canvas content
            const mainImg = new Image();
            mainImg.src = canvas.toDataURL();
            mainImg.onload = () => {
                ctx.drawImage(mainImg, padding, padding);

                // Draw summary text
                ctx.fillStyle = 'black';
                ctx.font = 'bold 18px Arial';
                ctx.fillText('Impervious Surface Calculation', padding, mainH + padding + 30);

                ctx.font = '16px Arial';
                const summaryEl = document.getElementById('summary');
                const lines = summaryEl.innerText.split('\n');
                lines.forEach((line, i) => {
                    ctx.fillText(line.trim(), padding, mainH + padding + 60 + i * 26);
                });

                // Draw legend on the right
                ctx.font = 'bold 15px Arial';
                ctx.fillText('LEGEND', mainW + padding * 2, padding + 30);

                let y = padding + 60;
                Object.entries(polygonColors).forEach(([type, color]) => {
                    // Color box
                    ctx.fillStyle = color;
                    ctx.fillRect(mainW + padding * 2, y - 15, 30, 20);
                    ctx.strokeStyle = '#444';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(mainW + padding * 2, y - 15, 30, 20);

                    // Label
                    ctx.fillStyle = 'black';
                    ctx.fillText(type.replace('-', ' ').toUpperCase(), mainW + padding * 2 + 45, y + 2);

                    y += 36;
                });

                // Download
                const dataURL = exportCanvas.toDataURL('image/png');
                download(dataURL, 'impervious_with_legend_calc.png');

                // Clean up
                if (selectedPolygon) addHandles(selectedPolygon);
            };
        });

        function download(dataURL, filename) {
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = filename;
            a.click();
        }

        // ───────────────────────────────────────────────
        // Mouse / drawing / editing logic (unchanged from previous)
        // ───────────────────────────────────────────────

        // ───────────────────────────────────────────────
// Improved mouse:down for drawing + scale
// ───────────────────────────────────────────────

let tempLine = null;  // for live preview while drawing

canvas.on('mouse:down', function(e) {
    if (!e.pointer) return;

    console.log('Mouse down detected at:', e.pointer);  // ← check console to confirm clicks register

    if (isSettingScale) {
        scalePoints.push(e.pointer);
        if (scalePoints.length === 2) {
            const pixelDist = Math.hypot(
                scalePoints[1].x - scalePoints[0].x,
                scalePoints[1].y - scalePoints[0].y
            );
            const realDist = parseFloat(prompt('Enter real-world distance in feet between the two points:'));
            if (!isNaN(realDist) && realDist > 0) {
                scale = realDist / pixelDist;
                alert(`Scale set: 1 pixel ≈ ${scale.toFixed(4)} ft`);
                updateSummary();
            }
            isSettingScale = false;
            scalePoints = [];
        }
        return;
    }

    if (isDrawing) {
        // Add point on single click
        currentPoints.push(e.pointer);

        // Live preview: draw temporary line to last point
        if (currentPoints.length >= 2) {
            if (tempLine) canvas.remove(tempLine);
            tempLine = new fabric.Line(
                [currentPoints[currentPoints.length-2].x, currentPoints[currentPoints.length-2].y,
                 currentPoints[currentPoints.length-1].x, currentPoints[currentPoints.length-1].y],
                { stroke: 'red', strokeWidth: 2, selectable: false }
            );
            canvas.add(tempLine);
            canvas.renderAll();
        }

        // Double-click detection moved to mouse:up for better reliability
    }
});

canvas.on('mouse:up', function(e) {
    if (isDrawing && currentPoints.length > 0) {
        // Simple double-click simulation using timing
        const now = Date.now();
        if (this._lastClickTime && now - this._lastClickTime < 300) {  // 300ms threshold
            // Double-click → close polygon
            if (currentPoints.length >= 3) {
                finishPolygon();
            } else {
                alert('Need at least 3 points to close a polygon.');
            }
        }
        this._lastClickTime = now;
    }
});

function finishPolygon() {
    if (tempLine) {
        canvas.remove(tempLine);
        tempLine = null;
    }

    const poly = new fabric.Polygon(currentPoints, {
        fill: polygonColors[currentType] || 'rgba(0,128,255,0.3)',
        stroke: 'black',
        strokeWidth: 2,
        opacity: 0.6,
        selectable: true,
        hasControls: true,
        objectCaching: false,
        type: currentType
    });

    canvas.add(poly);
    polygons.push(poly);
    canvas.setActiveObject(poly);

    isDrawing = false;
    currentPoints = [];
    canvas.selection = true;           // re-enable selection after drawing
    canvas.renderAll();
    updateSummary();
    alert('Polygon added. You can now select/move/edit it.');
}

        canvas.on('selection:created', e => {
            selectedPolygon = e.selected[0];
            if (selectedPolygon?.type === 'polygon') addHandles(selectedPolygon);
        });

        canvas.on('selection:updated', e => {
            removeHandles();
            selectedPolygon = e.selected[0];
            if (selectedPolygon?.type === 'polygon') addHandles(selectedPolygon);
        });

        canvas.on('selection:cleared', () => {
            removeHandles();
            selectedPolygon = null;
        });

        canvas.on('object:modified', updateSummary);

        function addHandles(poly) {
            removeHandles();
            poly.points.forEach((pt, i) => {
                const handle = new fabric.Circle({
                    left: pt.x,
                    top: pt.y,
                    radius: 6,
                    fill: 'white',
                    stroke: 'black',
                    strokeWidth: 2,
                    originX: 'center',
                    originY: 'center',
                    selectable: true,
                    hasControls: false,
                    hasBorders: false,
                    index: i,
                    parent: poly
                });
                handle.on('moving', function() {
                    const p = handle.parent.points[handle.index];
                    p.x = handle.left;
                    p.y = handle.top;
                    handle.parent.set({ points: [...handle.parent.points] });
                    handle.parent.setCoords();
                    canvas.renderAll();
                });
                canvas.add(handle);
                handles.push(handle);
            });
        }

        function removeHandles() {
            handles.forEach(h => canvas.remove(h));
            handles = [];
        }

        function getPolygonArea(points) {
            let area = 0;
            let j = points.length - 1;
            for (let i = 0; i < points.length; i++) {
                area += (points[j].x + points[i].x) * (points[j].y - points[i].y);
                j = i;
            }
            return Math.abs(area / 2);
        }

        function updateSummary() {
            if (scale === 0) {
                document.getElementById('summary').innerHTML = 'Scale not set. Please set scale first.';
                return;
            }
            let siteArea = 0;
            let impArea = 0;
            polygons.forEach(poly => {
                const pxArea = getPolygonArea(poly.points);
                const realArea = pxArea * scale * scale;
                if (poly.type === 'site') {
                    siteArea += realArea;
                } else if (['building','driveway','patio','other-impervious'].includes(poly.type)) {
                    impArea += realArea;
                }
            });
            const percent = siteArea > 0 ? (impArea / siteArea * 100).toFixed(2) : '0.00';
            document.getElementById('summary').innerHTML = 
                `Site Area: ${siteArea.toFixed(0)} sq ft<br>` +
                `Impervious Area: ${impArea.toFixed(0)} sq ft<br>` +
                `Impervious Percentage: ${percent}%`;
        }
    </script>
</body>
</html>



